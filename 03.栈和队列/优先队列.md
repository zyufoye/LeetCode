## 一、优先队列
优先队列可以在 $O(1)$ 时间内获得最大值，并且可以在 $O(log(n))$ 时间内取出最大值或插入任意值。  
优先队列常常用堆来实现。堆是一个完全二叉树，其每个节点的值总是大于等于子节点的值。实际实现堆时，我们通常用一个数组而不是用指针建立一个树。这是因为堆是完全二叉树，所以用数组表示时，位置 $i$ 的节点的父节点位置一定是 $(i-1)/2$，而他两个子节点的位置一定是 $2*i+1$ 和 $2*i+2$ （以上为假设数组索引从1开始，如果数组索引从0开始，则参考排序中的堆排序章节）。  
用堆来实现优先队列：最核心的两个操作是上浮和下沉。如果一个节点比父节点大，那么需要交换这两个节点，交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，我们称之为上浮；类似地，如果一个节点比父节点小，也需要不断地向下进行比较和交换操作，我们称之为下沉。如果一个节点有两个子节点，我们总是交换最大的子节点。  
代码实现：
```C++
class Solution {
public:
    vector<int> heap;

    //获得最大值
    int top() {
        return heap[0];
    }

    //插入任意值：把新数字放在最后一位，然后上浮
    void push(int k) {
        heap.push_back(k);
        swim(heap.size()-1);
    }
    //删除最大值：把最后一个数字放在堆顶，然后下沉
    void pop() {
        heap[0] = heap.back();
        heap.pop_back();
        sink(0);
    }
    //上浮
    void swim(int pos) {
        while (pos > 0 && heap[pos] > heap[(pos-1)/2]) {
            swap(heap[pos],heap[(pos-1)/2]);
            pos = (pos-1)/2;
        }
    }
    //下沉
    void sink(int pos) {
        int N = heap.size();
        while (2*pos +1 < N) {
            int i = 2*pos +1;
            if (i + 1 < N && heap[i] < heap[i + 1]) {
                i++; // 如果右子节点存在且更大，则 i 指向右子节点
            }
            if(heap[pos]>=heap[i])break;
            swap(heap[pos], heap[i]); // 交换当前节点与较大子节点的位置
            pos = i; // 更新当前节点的位置
        }
    }
};
```
## 二、合并有序链表
题目描述：给定k个增序链表，试着将他们合并成一条增序链表。  
解题思路：有一个比较快的写法，是将所有链表存储在一个优先队列中，每次提取所有链表头部节点值最小的那个节点，直到所有链表都被提取完为止。